```
メモ

落合さんが言っていたのが、とりあえずまとめる癖をつけるという事
前田さんが言っていたのが、アウトプットする癖をつけるという事

なので、今後も使いそうな奴はガシガシメモをとって行きたい。

あと、プログラムには実装そしてわかる事と、実装後に 理論的に理解できる部分があると思うので、
理論的な部分をココに残して行きたいと思う.

将来的にはEnglishでもとって行きたい。
英語の学習はInput と　Output をfifty-fiftyに保つ事が重要

```
Index自体は他にもあるが、B-tree Indexは平均点でともて優秀なIndexである

### B-tree Indexの特徴

#### 均一性
- 他の葉までの距離は等しい

#### 持続性
- データがどれだけ増えても検索スピードはO(log n)で変わらない 。普通はnに比例してO(n)

#### 処理汎用性
- 挿入、更新、排除もO(log n)この特性は、ビットマップインデックスにはない

#### 非等置性
- 探索範囲を絞れる(>, <, >=, =<)やBETWEEN などでは高速化が測れる
- 特定のノード以外全てを指す(!=, <>) などではBtree Indexは効果がない

#### 親ソート性

```
集約関数（ COUNT、 SUM、 AVG、 MAX、 MIN）
ORDER BY句
集合演算（ UNION、 INTERSECT、 EXCEPT）
OLAP 関数（ RANK、 ROW_ NUMBER など）
```

はDB内部でソートが行われるため、コストが高い演算である。


### B-tree Index の設計指針

#### 大規模なテーブルに対して作成
- グラフをイメージすればわかるが、データ量が少ないところにindexを貼っても意味がない

#### カーディナリティが高い列に作成
- カーディナリティとは特定の列の値が、どのぐらいの種類の多さを持つかという概念。

- 特定のキーを指定した時に、全体の5%程度以下になるだけのカーディナリティが必要
- 複合Indexの場合は、複合列の組み合わせの数がカーディナリティとなる
- カーディナリティが高くても、特定の値にデータが集中している場合は向いていない


#### Where句の選択条件、結合条件に使用されている列に作成する

- index適応列には演算を行わない
- index適応列には関数によって演算を行わない
- NULL はindexに適応されない(is NULL　where 句ではindexは無価値)
- OR または　否定形を用いている (OR を用いいるときはINを使う)
- LIKEは前方一致のみindexが有効
- 型変換(CAST)しない

#### その他条件
- 一意性制約列には作成不要
- データ更新は劣化する
- 定期的なメンテナンスが必要
